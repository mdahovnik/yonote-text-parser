import {TextNodeTree} from "./types/types.ts";

console.log("üí° content.ts is running:", document.readyState);

const ACT = {
  GET_DOCUMENT: 'GET_DOCUMENT',
  GET_DOCUMENTS: 'GET_DOCUMENTS',
  GET_SETTINGS: 'GET_SETTINGS',
  GET_DOCUMENT_ID: 'GET_DOCUMENT_ID',
  CLEAR_RECORDS: 'CLEAR_RECORDS',
  SAVE_DOCUMENT: 'SAVE_DOCUMENT',
  SAVE_SETTINGS: 'SAVE_SETTINGS',
  REMOVE_DOCUMENT: 'REMOVE_DOCUMENT',
  APPLY_SETTINGS: 'APPLY_SETTINGS',
  SET_BADGE: 'SET_BADGE',
  TEXT_CHANGED: 'TEXT_CHANGED',
  GET_NODE_TREE: 'GET_NODE_TREE'
}
const NEUTRAL_TAGS = ["SPAN", "LI", "P", 'TBODY', 'TR', 'TH', 'TD', 'PRE'];
const IGNORED_TAGS = ['BUTTON', 'OPTION'];
const VALID_CLASS_NAMES = [
  'notice-block info',
  "notice-block warning",
  "notice-block tip",
  'ordered_list',
  'bullet_list',
  'toggle',
  'checkbox_list',
  'columns',
  'code-block'
]
let currentHeading: "H1" | "H2" | "H3" | null = null;
let nodesTree: TextNodeTree[] = [];
let selectionToolbar: HTMLElement | null = null;

// –æ—Ç–∫—Ä—ã–≤–∞–µ–º –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ background.ts
let port = chrome.runtime.connect({name: "content-to-background"});
port.onDisconnect.addListener(reconnectPort);

function reconnectPort() {
  setTimeout(() => {
    port = chrome.runtime.connect({name: "content-to-background"});

    if (port) {
      port.onDisconnect.addListener(reconnectPort);
      console.log("–ü–æ—Ä—Ç –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω –∫ background...");
    } else {
      console.warn("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –ø–æ—Ä—Ç. –ü—Ä–æ–±—É–µ–º —Å–Ω–æ–≤–∞...");
      reconnectPort();
    }
  }, 500)
}

waitForOpenNewDocument(() => {
  waitForDocumentContainer(".hrehUE", (element: HTMLElement) => {
    waitForTextboxes(element, (textBoxes: Node[]) => {
      watchForTextChanges(textBoxes);
    });
  });
});

// –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å–∏–º–≤–æ–ª–æ–≤ –≤ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–π —á–∞—Å—Ç–∏ —Ç–µ–∫—Å—Ç–∞, —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∏ –≤—ã–¥–µ–ª–µ–Ω–∏–∏ –º—ã—à–∫–æ–π –∏ ctrl+a.
const characterIndicator = (() => {
  const characterIndicator = document.createElement('span');
  characterIndicator.textContent = '0';
  characterIndicator.style.fontSize = '18px';
  characterIndicator.style.display = 'flex';
  characterIndicator.style.alignItems = 'center';
  characterIndicator.style.borderRadius = '10%';
  characterIndicator.style.paddingInline = "5px";
  characterIndicator.style.backgroundColor = 'lightgreen';
  return characterIndicator;
})()

// –í–µ—à–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å–∏–º–≤–æ–ª–æ–≤ –≤–æ –≤—Å–ø–ª—ã–≤–∞—é—â–µ–µ –º–µ–Ω—é –ø–æ—è–≤–ª—è—é—â–µ–µ—Å—è –ø—Ä–∏ –≤—ã–¥–µ–ª–µ–Ω–∏–∏ (.selection-toolbar)
document.addEventListener('selectionchange', () => {
  const selection = window.getSelection();
  if (!selection || selection.rangeCount === 0) return;

  if (!selectionToolbar) {
    selectionToolbar = document.querySelector('.selection-toolbar');
    selectionToolbar?.appendChild(characterIndicator);
  } else {
    characterIndicator.textContent = `${selection?.toString().replace(/\n/g, '').length}`;
  }
})

// –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ document.head, –º—É—Ç–∞—Ü–∏–∏ –≤ head –ø—Ä–æ–∏—Å—Ö–æ–¥—è—Ç —Ç–æ–ª—å–∫–æ
// –ø—Ä–∏ –≤—ã–±–æ—Ä–µ –Ω–æ–≤–æ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è. –û—á–∏—â–∞–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ selectionToolbar, —Ç–∞–∫ –∫–∞–∫ –æ–Ω —Ç–æ–∂–µ –º—É—Ç–∏—Ä—É–µ—Ç.
// –≠—Ç–æ—Ç observer —Ä–∞–±–æ—Ç–∞–µ—Ç –ø–æ—Å—Ç–æ—è–Ω–Ω–æ –∏ –∫–∞—Å–∫–∞–¥–Ω–æ –∑–∞–ø—É—Å–∫–∞–µ—Ç –æ—Å—Ç–∞–ª—å–Ω—ã–µ.
function waitForOpenNewDocument(callback: Function) {
  const observer = new MutationObserver(() => {
    console.log('üü¢ NewDocument_Observer WORKING...');
    selectionToolbar = null;
    callback();
  })
  observer.observe(document.head, {childList: true, subtree: false, attributes: false, characterData: false});
}

// –ò—â–µ–º –±–ª–æ–∫ —Å class='hrehUE', –æ–Ω –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –º—É—Ç–∏—Ä—É–µ—Ç –∏ –µ–≥–æ –º–æ–∂–Ω–æ –æ—Ç—Å–ª–µ–¥–∏—Ç—å DocumentContainer_Observer
// –ü–æ—Å–ª–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –±–ª–æ–∫–∞ –¥–∏—Å–∫–æ–Ω–Ω–µ–∫—Ç–∏–º DocumentContainer_Observer.
function waitForDocumentContainer(selector: string, callback: (element: HTMLElement) => void) {
  const element = document.querySelector(selector) as HTMLElement;
  if (element) {
    callback(element);
    return;
  }

  const observer = new MutationObserver((mutations) => {
    console.log('üü¢ DocumentContainer_Observer WORKING...')
    for (const mutation of mutations) {
      mutation.addedNodes.forEach((node) => {
        if (node instanceof HTMLElement && node.matches(selector)) {
          callback(node);
          observer.disconnect();
          console.log('üü• DocumentContainer_Observer DISCONNECTED');
        }
      })
    }
  })
  observer.observe(document.body, {childList: true, subtree: true});
}

// –í –±–ª–æ–∫–µ —Å class='hrehUE' –∂–¥–µ–º –º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–µ–≥–æ–≤ —Å –∞—Ç—Ä–∏–±—É—Ç–æ–º role="textbox".
// –í –Ω–∏—Ö –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤—Å–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —É–∑–ª—ã –¥–æ–∫—É–º–µ–Ω—Ç–∞. –ü–æ—Å–ª–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –±–ª–æ–∫–∞ –¥–∏—Å–∫–æ–Ω–Ω–µ–∫—Ç–∏–º –µ–≥–æ.
function waitForTextboxes(element: HTMLElement, callback: (textBoxNodes: Node[]) => void) {
  const documentId = getCurrentDocumentId();
  let debounceTimer: number | null = null;

  const observer = new MutationObserver(() => {
    console.log('üü¢ TextBoxes_Observer WORKING...')

    if (debounceTimer) clearTimeout(debounceTimer);
    const textBoxNodes = element.querySelectorAll('[role="textbox"]');

    debounceTimer = setTimeout(() => {
      currentHeading = null;
      nodesTree = [];

      for (const textBoxNode of textBoxNodes) {
        nodesTree.push(createNodeTree(textBoxNode));
      }

      callback(Array.from(textBoxNodes));
      sendNodesTree(nodesTree, documentId);
      observer.disconnect();

      console.log('üü• TextBoxes_Observer DISCONNECTED');
    }, 300)
  });
  observer.observe(element, {childList: true, subtree: true});
}

// –ù–∞–±–ª—é–¥–∞–µ–º –∑–∞ –≤—Å–µ–º–∏ —Ç–µ–∫—Å—Ç–æ–≤—ã–º–∏ —É–∑–ª–∞–º–∏ –≤ —ç–ª–µ–º–µ–Ω—Ç–∞—Ö —Å role="textbox" –∏ –≤ —Ä–µ–∂–∏–º–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ —Ñ–∏–∫—Å–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ nodesTree.
// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º nodesTree —Å–ø–∞—Ä—Å–µ–Ω–Ω–æ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –≤ background.ts –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ nodesTreeCache
function watchForTextChanges(textBoxNodes: Node[]) {
  if (!textBoxNodes || textBoxNodes.length === 0) {
    console.log("‚ÄºÔ∏è no text nodes for observation.");
    return;
  }

  const documentId = getCurrentDocumentId();
  let debounceTimer: number | null = null;

  const observer = new MutationObserver(() => {
    console.log('üëÄ TextChanges_Observer WORKING...');

    if (debounceTimer) clearTimeout(debounceTimer);

    debounceTimer = setTimeout(() => {
      currentHeading = null;
      nodesTree = [];

      for (const textBoxNode of textBoxNodes) {
        nodesTree.push(createNodeTree(textBoxNode));
      }

      sendNodesTree(nodesTree, documentId);
    }, 200)
  })

  // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–ª–µ–∂–µ–Ω–∏–µ –∑–∞ –≤—Å–µ–º–∏ —Ç–µ–∫—Å—Ç–æ–≤—ã–º–∏ —É–∑–ª–∞–º–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
  for (const textBoxNode of textBoxNodes)
    observer.observe(textBoxNode, {characterData: true, subtree: true});
}

function sendNodesTree(nodesTree: TextNodeTree[], id: string) {
  if (!nodesTree || nodesTree.length === 0) {
    console.log("‚ÄºÔ∏è no nodesTree for sending.");
    return;
  }
  port.postMessage({
    action: ACT.GET_NODE_TREE,
    data: {nodeTree: nodesTree, id: id}
  });
}

// —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ö–æ–¥–∏–º —Ç–µ–∫—Å—Ç–æ–≤—ã–π –±–ª–æ–∫ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –∏ —Å—Ç—Ä–æ–∏–º —É–∑–ª–æ–≤–æ–µ –¥–µ—Ä–µ–≤–æ documentEditableTitle
function createNodeTree(nodeElement: Node, parentNodeNames: string[] = []) {
  const isNodeNameNeutral = NEUTRAL_TAGS.includes(nodeElement.nodeName);
  const isNodeContainClass = VALID_CLASS_NAMES.includes(getNodeNameFromClass(nodeElement));
  const titleNodeAttribute = (nodeElement as HTMLElement).hasAttribute('data-testid')
    ? (nodeElement as HTMLElement).getAttribute('data-testid')
    : '';

  let nodeNames = isNodeNameNeutral
    ? [...parentNodeNames]
    : [...parentNodeNames, isNodeContainClass
      ? getNodeNameFromClass(nodeElement)
      : nodeElement.nodeName]

  if (titleNodeAttribute && titleNodeAttribute.length > 0) nodeNames.push(titleNodeAttribute)

  const nodeTreeElement: TextNodeTree = {
    tag: nodeElement.nodeName,
    words: [],
    children: []
  };

  nodeElement.childNodes.forEach((node) => {
    if (node.nodeType === Node.TEXT_NODE) {
      if (currentHeading && nodeNames.includes(currentHeading))
        nodeNames = nodeNames.filter(name => name === currentHeading);

      // –†–∞–∑–±–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ —Å–ª–æ–≤–∞, —Ñ–∏–ª—å—Ç—Ä–æ–º —É–±–∏—Ä–∞–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Ö
      // –í tags —Å –ø–æ–º–æ—â—å—é new Set() –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Ç–µ–≥–∏
      const words = node.textContent?.trim().split(/\s+/).filter(w => w) || [];
      words.forEach(word => nodeTreeElement.words.push({word, tags: [...new Set(nodeNames)]}));

    } else if (node.nodeType === Node.ELEMENT_NODE) {
      if (!IGNORED_TAGS.includes(node.nodeName)) {
        switch (node.nodeName) {
          case "H1":
            currentHeading = "H1";
            break;
          case "H2":
            currentHeading = "H2";
            break;
          case "H3":
            currentHeading = "H3";
            break;
        }

        if (currentHeading) {
          nodeNames = nodeNames.filter(name => !name.includes(`_toggle_content`));
          nodeNames.push(`${currentHeading}_toggle_content`);
        }
        nodeTreeElement.children.push(createNodeTree(node, nodeNames));
      }
    }
  })
  return nodeTreeElement;
}

// –ï—Å–ª–∏ –Ω–æ–¥–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç class, —Ç–æ –ø–æ–ª—É—á–∞–µ–º –µ–≥–æ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –º–∞—Å—Å–∏–≤ —Ç–µ–≥–æ–≤, –æ–Ω–∏ –Ω—É–∂–Ω—ã –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞
// —Å —É—á–µ—Ç–æ–º VALID_CLASS_NAMES
function getNodeNameFromClass(node: Node) {
  if (node instanceof Element) {
    return node.classList.length > 0
      ? `${node.className}`
      : `${node.nodeName}`
  } else
    return node.nodeName;
}

function getCurrentDocumentId() {
  const mainDocContainer = document.getElementsByClassName("main-document-container");
  return mainDocContainer[0]?.getAttribute("id") || crypto.randomUUID();
}
